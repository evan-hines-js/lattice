# Node.js API server
# Outbound to: postgres, redis
# Inbound from: frontend, worker
apiVersion: lattice.dev/v1alpha1
kind: LatticeService
metadata:
  name: api
  namespace: webapp
spec:
  replicas: 1
  workload:
    containers:
      main:
        image: node:22-alpine
        command: ["node", "/app/server.js"]
        variables:
          PORT: "3000"
          DB_HOST: "postgres.webapp.svc.cluster.local"
          DB_PORT: "5432"
          DB_USER: "webapp"
          DB_NAME: "webapp"
          DB_PASSWORD: "${secret.db-credentials.password}"
          REDIS_HOST: "redis.webapp.svc.cluster.local"
          REDIS_PORT: "6379"
          REDIS_PASSWORD: "${secret.redis-credentials.password}"
        files:
          /app/server.js:
            content: |
              const http = require('http');
              const net = require('net');
              const port = process.env.PORT || 3000;

              function checkTcp(host, port) {
                return new Promise((resolve) => {
                  const sock = net.createConnection({ host, port: Number(port), timeout: 2000 });
                  sock.on('connect', () => { sock.destroy(); resolve(true); });
                  sock.on('error', () => resolve(false));
                  sock.on('timeout', () => { sock.destroy(); resolve(false); });
                });
              }

              const server = http.createServer(async (req, res) => {
                res.setHeader('Content-Type', 'application/json');

                if (req.url === '/health') {
                  res.writeHead(200);
                  return res.end(JSON.stringify({ status: 'ok', service: 'api' }));
                }

                if (req.url === '/api/status') {
                  const [pgOk, redisOk] = await Promise.all([
                    checkTcp(process.env.DB_HOST, process.env.DB_PORT),
                    checkTcp(process.env.REDIS_HOST, process.env.REDIS_PORT),
                  ]);
                  res.writeHead(200);
                  return res.end(JSON.stringify({
                    service: 'api',
                    uptime: Math.round(process.uptime()),
                    timestamp: new Date().toISOString(),
                    dependencies: { postgres: pgOk ? 'up' : 'down', redis: redisOk ? 'up' : 'down' },
                  }));
                }

                res.writeHead(404);
                res.end(JSON.stringify({ error: 'not found' }));
              });

              server.listen(port, () => console.log(`API listening on :${port}`));
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 256Mi
        readinessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 10
    service:
      ports:
        http:
          port: 3000
          protocol: TCP
    resources:
      db-credentials:
        type: secret
        id: webapp/db-credentials
        params:
          provider: lattice-local
          keys:
            - password
      redis-credentials:
        type: secret
        id: webapp/redis-credentials
        params:
          provider: lattice-local
          keys:
            - password
      postgres:
        type: service
        direction: outbound
      redis:
        type: service
        direction: outbound
      frontend:
        type: service
        direction: inbound
      worker:
        type: service
        direction: inbound
