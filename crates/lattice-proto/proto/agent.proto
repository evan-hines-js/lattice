// Lattice Agent-Cell Communication Protocol
//
// This defines the gRPC services between workload cluster agents and their
// parent cell (management cluster). All connections are initiated OUTBOUND
// from workload clusters - cells never connect to agents.
//
// Pivot flow: Parent pauses CAPI → exports via --to-directory → sends to child
//             → child imports → child unpauses
// Unpivot flow: Child pauses CAPI → exports via --to-directory → sends to parent
//               → parent imports → parent unpauses → parent deletes

syntax = "proto3";
package lattice.agent.v1;

import "google/protobuf/timestamp.proto";

// =============================================================================
// Services
// =============================================================================

// LatticeAgent service - agent connects to cell
//
// The agent initiates an outbound connection to the cell's gRPC server.
// This establishes a stream for control messages.
service LatticeAgent {
  // Bidirectional stream for control messages (heartbeat, commands, status)
  // Agent initiates, maintains persistent connection
  rpc StreamMessages(stream AgentMessage) returns (stream CellCommand);
}

// =============================================================================
// Control Messages: Agent to Cell
// =============================================================================

// Wrapper for all agent-to-cell messages
message AgentMessage {
  // Name of the cluster this agent manages
  string cluster_name = 1;

  oneof payload {
    AgentReady ready = 2;
    BootstrapComplete bootstrap_complete = 3;
    PivotComplete pivot_complete = 4;
    Heartbeat heartbeat = 5;
    ClusterHealth cluster_health = 6;
    StatusResponse status_response = 7;
    ClusterDeleting cluster_deleting = 8;
  }
}

// Sent when cluster deletion is initiated (unpivot)
//
// Unpivot is pivot in reverse: child pauses CAPI, exports via --to-directory,
// sends manifests to parent. Parent imports, unpauses, then deletes.
// This ensures parent has all resources including any nodes added post-pivot.
message ClusterDeleting {
  // Namespace where CAPI resources live
  string namespace = 1;
  // CAPI manifests exported via clusterctl move --to-directory
  // Parent will import these before cleanup to get any new nodes/machines
  repeated bytes capi_manifests = 2;
}

// Sent when agent first connects to cell
message AgentReady {
  // Version of the lattice agent binary
  string agent_version = 1;
  // Kubernetes version running on this cluster
  string kubernetes_version = 2;
  // Current state of the agent
  AgentState state = 3;
  // API server endpoint (for informational purposes)
  string api_server_endpoint = 4;
}

// Sent when agent has completed initial setup
// (CAPI provider installed, controller reconciling)
message BootstrapComplete {
  // CAPI provider successfully installed based on LatticeCluster spec
  bool capi_ready = 1;
  // List of installed providers (e.g., ["docker", "kubeadm"])
  repeated string installed_providers = 2;
}

// Sent when pivot operation completes
message PivotComplete {
  // Whether pivot succeeded
  bool success = 1;
  // Error message if success=false
  string error_message = 2;
  // Number of CAPI resources imported
  int32 resources_imported = 3;
}

// Periodic heartbeat with agent state
message Heartbeat {
  // Current agent state
  AgentState state = 1;
  // Timestamp of this heartbeat
  google.protobuf.Timestamp timestamp = 2;
  // Uptime in seconds
  int64 uptime_seconds = 3;
}

// Cluster health information
message ClusterHealth {
  // Number of ready nodes
  int32 ready_nodes = 1;
  // Total number of nodes
  int32 total_nodes = 2;
  // Ready control plane nodes
  int32 ready_control_plane = 3;
  // Total control plane nodes
  int32 total_control_plane = 4;
  // Kubernetes conditions (Ready, MemoryPressure, etc.)
  repeated NodeCondition conditions = 5;
}

// Response to StatusRequest
message StatusResponse {
  // Correlates to the StatusRequest command_id
  string request_id = 1;
  // Current agent state
  AgentState state = 2;
  // Cluster health
  ClusterHealth health = 3;
  // CAPI resource counts (if requested)
  CapiStatus capi_status = 4;
}

// Kubernetes node condition
message NodeCondition {
  string type = 1;
  string status = 2;
  string reason = 3;
  string message = 4;
}

// CAPI resource status
message CapiStatus {
  int32 cluster_count = 1;
  int32 machine_count = 2;
  int32 machine_deployment_count = 3;
  bool has_control_plane = 4;
}

// Agent state machine
enum AgentState {
  AGENT_STATE_UNKNOWN = 0;
  // Cluster infrastructure is being provisioned by CAPI
  AGENT_STATE_PROVISIONING = 1;
  // CAPI resources are being imported (pivot in progress)
  AGENT_STATE_PIVOTING = 2;
  // Cluster is fully operational and self-managing
  AGENT_STATE_READY = 3;
  // Cluster has issues but is still operational
  AGENT_STATE_DEGRADED = 4;
  // Cluster is in a failed state
  AGENT_STATE_FAILED = 5;
}

// =============================================================================
// Control Messages: Cell to Agent
// =============================================================================

// Wrapper for all cell-to-agent commands
message CellCommand {
  // Unique ID for this command (for idempotency and correlation)
  string command_id = 1;

  oneof command {
    ApplyManifestsCommand apply_manifests = 2;
    StatusRequest status_request = 3;
    PivotManifestsCommand pivot_manifests = 4;
  }
}

message ApplyManifestsCommand {
  repeated bytes manifests = 1;
}

message PivotManifestsCommand {
  // YAML manifests exported via clusterctl move --to-directory
  repeated bytes manifests = 1;
  // Namespace to import into
  string target_namespace = 2;
  // Cluster name
  string cluster_name = 3;
  // Secrets to distribute (labeled lattice.io/distribute: "true")
  // Applied to lattice-system namespace on child cluster
  repeated bytes secrets = 4;
}

// Request current cluster status
message StatusRequest {
  // Whether to include detailed node information
  bool include_nodes = 1;
  // Whether to include CAPI resource status
  bool include_capi = 2;
}
