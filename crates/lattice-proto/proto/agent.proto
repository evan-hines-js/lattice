// Lattice Agent-Cell Communication Protocol
//
// This defines the gRPC services between workload cluster agents and their
// parent cell (management cluster). All connections are initiated OUTBOUND
// from workload clusters - cells never connect to agents.
//
// Pivot flow: Parent pauses CAPI → exports via --to-directory → sends to child
//             → child imports → child unpauses
// Unpivot flow: Child pauses CAPI → exports via --to-directory → sends to parent
//               → parent imports → parent unpauses → parent deletes

syntax = "proto3";
package lattice.agent.v1;

import "google/protobuf/timestamp.proto";

// =============================================================================
// Services
// =============================================================================

// LatticeAgent service - agent connects to cell
//
// The agent initiates an outbound connection to the cell's gRPC server.
// This establishes a stream for control messages.
service LatticeAgent {
  // Bidirectional stream for control messages (heartbeat, commands, status)
  // Agent initiates, maintains persistent connection
  rpc StreamMessages(stream AgentMessage) returns (stream CellCommand);
}

// =============================================================================
// Control Messages: Agent to Cell
// =============================================================================

// Wrapper for all agent-to-cell messages
message AgentMessage {
  // Name of the cluster this agent manages
  string cluster_name = 1;

  oneof payload {
    AgentReady ready = 2;
    BootstrapComplete bootstrap_complete = 3;
    PivotComplete pivot_complete = 4;
    Heartbeat heartbeat = 5;
    ClusterHealth cluster_health = 6;
    StatusResponse status_response = 7;
    ClusterDeleting cluster_deleting = 8;
    KubernetesResponse kubernetes_response = 9;
  }
}

// Sent when cluster deletion is initiated (unpivot)
//
// Unpivot is pivot in reverse: child pauses CAPI, exports via --to-directory,
// sends manifests to parent. Parent imports, unpauses, then deletes.
// This ensures parent has all resources including any nodes added post-pivot.
message ClusterDeleting {
  // Namespace where CAPI resources live
  string namespace = 1;
  // CAPI manifests exported via clusterctl move --to-directory
  // Parent will import these before cleanup to get any new nodes/machines
  repeated bytes capi_manifests = 2;
}

// Sent when agent first connects to cell
message AgentReady {
  // Version of the lattice agent binary
  string agent_version = 1;
  // Kubernetes version running on this cluster
  string kubernetes_version = 2;
  // Current state of the agent
  AgentState state = 3;
  // API server endpoint (for informational purposes)
  string api_server_endpoint = 4;
  // Current pivot phase (for crash recovery - parent sends resources if ApplyingResources)
  PivotPhase pivot_phase = 5;
  // Current unpivot phase (for crash recovery - parent resends ACK if WaitingForAck)
  UnpivotPhase unpivot_phase = 6;
}

// Sub-phase of pivot process for crash recovery
enum PivotPhase {
  PIVOT_PHASE_NONE = 0;
  // CAPI manifests received, import in progress
  PIVOT_PHASE_IMPORTING = 1;
  // CAPI imported, patching kubeconfig
  PIVOT_PHASE_PATCHING_KUBECONFIG = 2;
  // Kubeconfig patched, applying distributed resources
  PIVOT_PHASE_APPLYING_RESOURCES = 3;
  // All pivot steps complete
  PIVOT_PHASE_COMPLETE = 4;
}

// Sent when agent has completed initial setup
// (CAPI provider installed, controller reconciling)
message BootstrapComplete {
  // CAPI provider successfully installed based on LatticeCluster spec
  bool capi_ready = 1;
  // List of installed providers (e.g., ["docker", "kubeadm"])
  repeated string installed_providers = 2;
}

// Sent when pivot operation completes
message PivotComplete {
  // Whether pivot succeeded
  bool success = 1;
  // Error message if success=false
  string error_message = 2;
  // Number of CAPI resources imported
  int32 resources_imported = 3;
}

// Periodic heartbeat with agent state
message Heartbeat {
  // Current agent state
  AgentState state = 1;
  // Timestamp of this heartbeat
  google.protobuf.Timestamp timestamp = 2;
  // Uptime in seconds
  int64 uptime_seconds = 3;
}

// Cluster health information
message ClusterHealth {
  // Number of ready nodes
  int32 ready_nodes = 1;
  // Total number of nodes
  int32 total_nodes = 2;
  // Ready control plane nodes
  int32 ready_control_plane = 3;
  // Total control plane nodes
  int32 total_control_plane = 4;
  // Kubernetes conditions (Ready, MemoryPressure, etc.)
  repeated NodeCondition conditions = 5;
}

// Response to StatusRequest
message StatusResponse {
  // Correlates to the StatusRequest command_id
  string request_id = 1;
  // Current agent state
  AgentState state = 2;
  // Cluster health
  ClusterHealth health = 3;
  // CAPI resource counts (if requested)
  CapiStatus capi_status = 4;
}

// Kubernetes node condition
message NodeCondition {
  string type = 1;
  string status = 2;
  string reason = 3;
  string message = 4;
}

// CAPI resource status
message CapiStatus {
  int32 cluster_count = 1;
  int32 machine_count = 2;
  int32 machine_deployment_count = 3;
  bool has_control_plane = 4;
}

// Agent state machine
enum AgentState {
  AGENT_STATE_UNKNOWN = 0;
  // Cluster infrastructure is being provisioned by CAPI
  AGENT_STATE_PROVISIONING = 1;
  // CAPI resources are being imported (pivot in progress)
  AGENT_STATE_PIVOTING = 2;
  // Cluster is fully operational and self-managing
  AGENT_STATE_READY = 3;
  // Cluster has issues but is still operational
  AGENT_STATE_DEGRADED = 4;
  // Cluster is in a failed state
  AGENT_STATE_FAILED = 5;
}

// =============================================================================
// Control Messages: Cell to Agent
// =============================================================================

// Wrapper for all cell-to-agent commands
message CellCommand {
  // Unique ID for this command (for idempotency and correlation)
  string command_id = 1;

  oneof command {
    ApplyManifestsCommand apply_manifests = 2;
    StatusRequest status_request = 3;
    PivotManifestsCommand pivot_manifests = 4;
    SyncDistributedResourcesCommand sync_resources = 5;
    UnpivotAckCommand unpivot_ack = 6;
    KubernetesRequest kubernetes_request = 7;
  }
}

message ApplyManifestsCommand {
  repeated bytes manifests = 1;
}

message PivotManifestsCommand {
  // YAML manifests exported via clusterctl move --to-directory
  repeated bytes manifests = 1;
  // Namespace to import into
  string target_namespace = 2;
  // Cluster name
  string cluster_name = 3;
  // CloudProvider CRDs (YAML)
  repeated bytes cloud_providers = 4;
  // SecretsProvider CRDs (YAML)
  repeated bytes secrets_providers = 5;
  // Secrets referenced by providers (YAML)
  repeated bytes secrets = 6;
}

// Sync distributable resources to child cluster
// Used for both watch-triggered updates and periodic reconciliation
message SyncDistributedResourcesCommand {
  // CloudProvider CRDs (YAML)
  repeated bytes cloud_providers = 1;
  // SecretsProvider CRDs (YAML)
  repeated bytes secrets_providers = 2;
  // Secrets referenced by providers (YAML)
  repeated bytes secrets = 3;
  // If true, delete resources not in this list (full sync)
  // If false, only add/update (incremental)
  bool full_sync = 4;
}

// Request current cluster status
message StatusRequest {
  // Whether to include detailed node information
  bool include_nodes = 1;
  // Whether to include CAPI resource status
  bool include_capi = 2;
}

// Acknowledge receipt of unpivot manifests from child
// Sent by parent after persisting manifests and initiating deletion
// Child can safely remove its finalizer after receiving this
message UnpivotAckCommand {
  // Whether the parent successfully received and persisted manifests
  bool success = 1;
  // Error message if success=false
  string error_message = 2;
}

// Sub-phase of unpivot process (child → parent reporting)
enum UnpivotPhase {
  UNPIVOT_PHASE_NONE = 0;
  // Exporting CAPI resources
  UNPIVOT_PHASE_EXPORTING = 1;
  // Sending manifests to parent
  UNPIVOT_PHASE_SENDING = 2;
  // Waiting for parent ACK
  UNPIVOT_PHASE_WAITING_FOR_ACK = 3;
  // Parent ACKed, complete
  UNPIVOT_PHASE_COMPLETE = 4;
}

// =============================================================================
// K8s API Proxy Messages
// =============================================================================

// Cell → Agent: Request to execute against child's K8s API
// Enables parent to access child cluster K8s API through the gRPC stream.
message KubernetesRequest {
  // Unique ID for correlation (UUID, never reused in session)
  string request_id = 1;

  // HTTP verb: GET, LIST, POST, PUT, PATCH, DELETE
  // LIST is GET with collection path, WATCH is GET with ?watch=true
  string verb = 2;

  // API path: /api/v1/namespaces/default/pods/nginx
  // /apis/apps/v1/namespaces/default/deployments
  string path = 3;

  // Query string (URL-encoded): watch=true&labelSelector=app%3Dnginx
  string query = 4;

  // Request body for POST/PUT/PATCH (JSON or YAML)
  bytes body = 5;

  // Content-Type: application/json, application/yaml,
  // application/strategic-merge-patch+json, etc.
  string content_type = 6;

  // Timeout in milliseconds. 0 = default (30s for non-watch, none for watch)
  uint32 timeout_ms = 7;

  // Set to true to cancel an active watch by request_id
  // Agent will stop the watch and send stream_end response
  bool cancel = 8;
}

// Agent → Cell: Response from child's K8s API
message KubernetesResponse {
  // Correlates to KubernetesRequest.request_id
  string request_id = 1;

  // HTTP status code: 200, 201, 404, 500, etc.
  uint32 status_code = 2;

  // Response body (JSON)
  // For watches: each event is a separate response message
  bytes body = 3;

  // Content-Type from K8s API response
  string content_type = 4;

  // True if this is a streaming watch response
  // Client should expect multiple responses with same request_id
  bool streaming = 5;

  // True if this is the final message in a stream
  // After this, no more responses for this request_id
  bool stream_end = 6;

  // Error message for internal errors (not K8s API errors)
  // K8s API errors come through status_code + body
  string error = 7;
}
