// Lattice Agent-Cell Communication Protocol
//
// This defines the gRPC services between workload cluster agents and their
// parent cell (management cluster). All connections are initiated OUTBOUND
// from workload clusters - cells never connect to agents.
//
// Key design: The agent exposes a K8s API proxy through gRPC, allowing the
// cell to run `clusterctl move --to-kubeconfig` directly through the tunnel.

syntax = "proto3";
package lattice.agent.v1;

import "google/protobuf/timestamp.proto";

// =============================================================================
// Services
// =============================================================================

// LatticeAgent service - agent connects to cell
//
// The agent initiates an outbound connection to the cell's gRPC server.
// This establishes streams for control messages and K8s API proxying.
service LatticeAgent {
  // Bidirectional stream for control messages (heartbeat, commands, status)
  // Agent initiates, maintains persistent connection
  rpc StreamMessages(stream AgentMessage) returns (stream CellCommand);

  // K8s API proxy - allows cell to execute kubectl commands on agent's cluster
  // Used for: clusterctl move --to-kubeconfig, debugging, monitoring
  // Agent calls this to register, cell sends requests, agent returns responses
  rpc ProxyKubernetesAPI(stream KubeProxyResponse) returns (stream KubeProxyRequest);
}

// =============================================================================
// K8s API Proxy Messages
// =============================================================================

// Request from cell to agent - proxied K8s API call
message KubeProxyRequest {
  // Unique request ID for correlation
  string request_id = 1;

  // HTTP method (GET, POST, PUT, PATCH, DELETE, etc.)
  string method = 2;

  // Request path (e.g., /api/v1/namespaces/default/pods)
  string path = 3;

  // HTTP headers (repeated key-value pairs)
  repeated HttpHeader headers = 4;

  // Request body (for POST, PUT, PATCH)
  bytes body = 5;
}

// Response from agent to cell - proxied K8s API response
//
// For streaming responses (like K8s watch), multiple messages with the same
// request_id will be sent. The first message contains status_code and headers.
// Subsequent messages contain body chunks. The final message has is_final=true.
message KubeProxyResponse {
  // Correlation ID matching the request
  string request_id = 1;

  // HTTP status code (200, 404, 500, etc.) - only set in first message
  int32 status_code = 2;

  // Response headers - only set in first message
  repeated HttpHeader headers = 3;

  // Response body (or chunk for streaming responses)
  bytes body = 4;

  // Error message if proxy itself failed (not K8s API error)
  string error = 5;

  // True if this is a streaming response (more chunks may follow)
  bool is_streaming = 6;

  // True if this is the final chunk of a streaming response
  bool is_final = 7;
}

// HTTP header key-value pair
message HttpHeader {
  string key = 1;
  string value = 2;
}

// =============================================================================
// Control Messages: Agent to Cell
// =============================================================================

// Wrapper for all agent-to-cell messages
message AgentMessage {
  // Name of the cluster this agent manages
  string cluster_name = 1;

  oneof payload {
    AgentReady ready = 2;
    BootstrapComplete bootstrap_complete = 3;
    PivotStarted pivot_started = 4;
    PivotComplete pivot_complete = 5;
    Heartbeat heartbeat = 6;
    ClusterHealth cluster_health = 7;
    StatusResponse status_response = 8;
  }
}

// Sent when agent first connects to cell
message AgentReady {
  // Version of the lattice agent binary
  string agent_version = 1;
  // Kubernetes version running on this cluster
  string kubernetes_version = 2;
  // Current state of the agent
  AgentState state = 3;
  // API server endpoint (for informational purposes)
  string api_server_endpoint = 4;
}

// Sent when agent has completed initial setup
// (CAPI provider installed, controller reconciling)
message BootstrapComplete {
  // CAPI provider successfully installed based on LatticeCluster spec
  bool capi_ready = 1;
  // List of installed providers (e.g., ["docker", "kubeadm"])
  repeated string installed_providers = 2;
}

// Sent when agent begins pivot (CAPI import starting)
message PivotStarted {
  // Namespace where CAPI resources will be imported
  string target_namespace = 1;
}

// Sent when pivot operation completes
message PivotComplete {
  // Whether pivot succeeded
  bool success = 1;
  // Error message if success=false
  string error_message = 2;
  // Number of CAPI resources imported
  int32 resources_imported = 3;
}

// Periodic heartbeat with agent state
message Heartbeat {
  // Current agent state
  AgentState state = 1;
  // Timestamp of this heartbeat
  google.protobuf.Timestamp timestamp = 2;
  // Uptime in seconds
  int64 uptime_seconds = 3;
}

// Cluster health information
message ClusterHealth {
  // Number of ready nodes
  int32 ready_nodes = 1;
  // Total number of nodes
  int32 total_nodes = 2;
  // Ready control plane nodes
  int32 ready_control_plane = 3;
  // Total control plane nodes
  int32 total_control_plane = 4;
  // Kubernetes conditions (Ready, MemoryPressure, etc.)
  repeated NodeCondition conditions = 5;
}

// Response to StatusRequest
message StatusResponse {
  // Correlates to the StatusRequest command_id
  string request_id = 1;
  // Current agent state
  AgentState state = 2;
  // Cluster health
  ClusterHealth health = 3;
  // CAPI resource counts (if requested)
  CapiStatus capi_status = 4;
}

// Kubernetes node condition
message NodeCondition {
  string type = 1;
  string status = 2;
  string reason = 3;
  string message = 4;
}

// CAPI resource status
message CapiStatus {
  int32 cluster_count = 1;
  int32 machine_count = 2;
  int32 machine_deployment_count = 3;
  bool has_control_plane = 4;
}

// Agent state machine
enum AgentState {
  AGENT_STATE_UNKNOWN = 0;
  // Cluster infrastructure is being provisioned by CAPI
  AGENT_STATE_PROVISIONING = 1;
  // CAPI resources are being imported (pivot in progress)
  AGENT_STATE_PIVOTING = 2;
  // Cluster is fully operational and self-managing
  AGENT_STATE_READY = 3;
  // Cluster has issues but is still operational
  AGENT_STATE_DEGRADED = 4;
  // Cluster is in a failed state
  AGENT_STATE_FAILED = 5;
}

// =============================================================================
// Control Messages: Cell to Agent
// =============================================================================

// Wrapper for all cell-to-agent commands
message CellCommand {
  // Unique ID for this command (for idempotency and correlation)
  string command_id = 1;

  oneof command {
    ApplyManifestsCommand apply_manifests = 2;
    StartPivotCommand start_pivot = 3;
    StatusRequest status_request = 4;
  }
}

// Command to apply Kubernetes manifests
//
// Used for:
// - Post-pivot setup: LatticeCluster CRD + self-referential resource
// - The controller reconciles LatticeCluster and lazily installs CAPI
message ApplyManifestsCommand {
  // YAML manifests to apply (will be kubectl apply -f)
  repeated bytes manifests = 1;
}

// Command to start pivot - cell will use K8s proxy for clusterctl move
//
// Flow:
// 1. Cell sends StartPivotCommand
// 2. Agent sends PivotStarted, enters PIVOTING state
// 3. Cell runs clusterctl move with proxy kubeconfig (via ProxyKubernetesAPI)
// 4. Agent detects CAPI resources imported, sends PivotComplete
message StartPivotCommand {
  // Source namespace on cell where CAPI resources currently live
  string source_namespace = 1;
  // Target namespace on agent where CAPI resources should go
  string target_namespace = 2;
  // Name of the cluster being pivoted
  string cluster_name = 3;
}

// Request current cluster status
message StatusRequest {
  // Whether to include detailed node information
  bool include_nodes = 1;
  // Whether to include CAPI resource status
  bool include_capi = 2;
}
